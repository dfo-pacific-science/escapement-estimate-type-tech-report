# Methods

## Design principles (Hyatt-aligned)

Hyatt (1997) intended estimate-type assignment to reflect (i) method properties, (ii) statistical properties, and (iii) documentation [@hyatt1997]. The updated guidance encodes these dimensions explicitly as decision gates, method-family checks, and final evidence requirements.

```{r hyatt-mapping-table}
hyatt_mapping <- data.frame(
  `Hyatt (1997) dimension` = c(
    "Method properties (survey + analysis)",
    "Statistical properties (units, accuracy, precision)",
    "Documentation"
  ),
  `How the updated guidance encodes it` = c(
    "Method families + property checks (coverage, effort, timing, visibility, cross-section coverage)",
    "Type eligibility by method family and a final precision/accuracy gate (supports CV/SE where available)",
    "Documentation qualifier + final documentation enforcement"
  ),
  check.names = FALSE
)

csas_kable(
  hyatt_mapping,
  escape = TRUE,
  bold_header = FALSE,
  font_size = 9,
  align = c("l", "l"),
  caption = "Mapping of Hyatt (1997) intent to the updated, property-first guidance implementation."
) |>
  csas_colspec(1, width = "5.0cm") |>
  csas_colspec(2, width = "10.0cm")
```

## Decision key design

The classification follows a property-first sequence:

1. **Data format gate**: non-numeric presence/not-detected is classified as Type 6.
2. **Method known gate**: if survey and analytical methods are not identified, the estimate is provisionally Type 5 and flagged as method-unknown.
3. **Method family selection**: a primary method family scopes the applicable questions.
4. **Method-family checks**: coverage, effort, visibility, timing, and related criteria drive conservative downgrades.
5. **Final checks**: documentation and uncertainty evidence are evaluated; where evidence is missing, conservative downgrades apply.

This structure is intended to reduce subjective table interpretation by turning common qualifiers into explicit questions and recorded qualifier codes.

## Software availability (implementation of the guidance)

The decision key and execution logic are implemented in a companion toolkit repository:

- Repository: `dfo-pacific-science/smn-escapement-estimates-toolkit`
- Release/tag: **TBD**

For the purposes of this report, it is sufficient to note that the software executes one canonical decision key and produces (i) an estimate Type (1--6) and (ii) explicit qualifier codes explaining conservative downgrades.

## Handling common operational complications

The updated guidance treats several recurring complications as explicit qualifiers rather than implicit judgement calls.

### Breaches/bypass and infilling

Breach/bypass events at counting sites, and periods of missing observation due to outages or missed visits, can materially affect interpretability unless the magnitude and correction method are documented. The updated guidance treats bypass/breach risk and incomplete coverage as explicit downgrade triggers and records whether defensible infilling/interpolation was required [@velezEspino2010atnarko; @holmes2005didson; @see2021stateSpace].

### Survey timing relative to run timing

For survey-based indices, visit count alone is not sufficient: surveys must bracket the period when fish are present, and visibility constraints and observer effects can govern bias and comparability [@holtCox2008visual; @jones1998observer; @korman2002observerEfficiency; @hill1997aerialFrequency]. The updated guidance includes timing and visibility checks within method families where these factors are primary drivers of interpretability.

### Combined-method estimates

Combined-method workflows (e.g., system-wide sonar with tributary visual apportionment, or fences supplemented during breach periods) should be recorded as explicit components. The updated guidance applies a conservative rule: where multiple components contribute to the final estimate, the assigned Type should not exceed that implied by the weakest component unless a documented integration method supports a higher classification [@parsonsSkalski2010escTechniques].

### Calibration and historical revisions

Where historical values have been recalibrated or revised, the updated guidance treats calibration as an analysis layer that should be captured in metadata (calibration source, diagnostics, and revision history) rather than as a new estimate Type. This supports interpretation of time-series values by downstream users.

### Quantitative uncertainty (CV/SE)

Hyatt (1997) distinguished higher-quality absolute-abundance estimates in part by qualified precision (variance evidence) [@hyatt1997]. Where available, reporting quantitative uncertainty (e.g., CV or SE) improves interpretability for downstream use. For example, AUC and peak-count approaches have established approaches for incorporating uncertainty and evaluating sensitivity to survey timing and frequency [@english1992auc; @hilborn1999periodic; @hill1997aerialFrequency; @parken2003aucUncertainty; @millar2012auc]. The updated guidance includes a final precision/accuracy check and recommends capturing quantitative uncertainty when available.

## Recommended metadata elements for New SEDS/NuSEDS

The updated guidance can be expressed using existing NuSEDS fields in many cases, but several high-value metadata elements are needed to make estimate Types interpretable and reproducible for downstream users.

**Note:** The field names below are illustrative. The key point is that these elements are (i) recorded by the guidance as explicit qualifier codes and (ii) recommended for storage in New SEDS/NuSEDS so that Type assignment is transparent to data users.

```{r recommended-metadata-table}
recommended_meta <- data.frame(
  `Metadata element` = c(
    "Enumeration method (field)",
    "Estimation method (analysis)",
    "Primary method family (FS/V/A/S/T/R/P/M)",
    "Run-window coverage evidence",
    "Device/site uptime evidence",
    "Breach/bypass context",
    "Infilling/interpolation method",
    "Survey timing relative to run timing",
    "Visibility/conditions",
    "Documentation evidence",
    "Quantitative uncertainty (CV/SE)",
    "Combined-method components",
    "Calibration source + diagnostics",
    "Revision history (what changed/when)"
  ),
  `Why it matters for interpretation` = c(
    "Scopes which property checks apply.",
    "Distinguishes analysis pathways (e.g., mark--recapture, AUC, modelling).",
    "Controls eligibility rules and the set of required qualifiers.",
    "Explains conservative downgrades due to missed start/end of run.",
    "Explains conservative downgrades due to outages/unobserved intervals.",
    "Explains conservative downgrades where missed fish are plausible.",
    "Distinguishes defensible correction from undocumented gap-filling.",
    "A core driver of bias and comparability for survey indices.",
    "Affects detectability and comparability (especially for visual methods).",
    "Determines whether a downstream user can independently interpret the estimate.",
    "Supports qualified precision for Type 2 and more transparent uncertainty.",
    "Prevents concealment of a weaker component within an overall estimate.",
    "Supports interpretation of recalibrated time series.",
    "Supports transparency when historical values have been revised."
  ),
  `Typical qualifier code(s)` = c(
    "METHOD_UNKNOWN (if missing)",
    "METHOD_UNKNOWN (if missing)",
    "METHOD_UNKNOWN (if missing)",
    "RUN_COVERAGE",
    "UPTIME",
    "BREACH_BYPASS",
    "INFILL_METHOD",
    "TIMING",
    "VISIBILITY / ENV_COND",
    "DOC",
    "PRECISION_ACCURACY",
    "(varies; conservative component rule)",
    "(varies)",
    "(varies)"
  ),
  `Priority for upload` = c(
    "Required",
    "Required",
    "Required",
    "Recommended",
    "Recommended",
    "Recommended",
    "Recommended",
    "Recommended",
    "Recommended",
    "Required",
    "Recommended",
    "Recommended",
    "Recommended",
    "Recommended"
  ),
  check.names = FALSE
)

csas_kable(
  recommended_meta,
  escape = TRUE,
  bold_header = FALSE,
  font_size = 8,
  align = c("l", "l", "l", "c"),
  caption = "Recommended metadata elements for New SEDS/NuSEDS uploads to support transparent Type 1--6 assignment and interpretation."
) |>
  csas_colspec(1, width = "3.7cm") |>
  csas_colspec(2, width = "7.0cm") |>
  csas_colspec(3, width = "3.0cm") |>
  csas_colspec(4, width = "2.3cm")
```

## NuSEDS data dictionary alignment

The NuSEDS data dictionary defines the database fields used to store enumeration methods, estimation methods, estimate classification (Types 1--6), and supporting metadata (e.g., inspections/effort and timing fields) [@openCanadaNuSEDSDataDictionary]. The updated guidance is designed to be expressible using existing NuSEDS fields where possible, and to clearly identify gaps where additional metadata would improve interpretation and reproducibility.

```{r nuseds-fields-table}
dd_path <- file.path("docs", "context", "Data_Dictionary_NuSEDS_EN.csv")

wanted_fields <- c(
  "ESTIMATE_CLASSIFICATION",
  "ENUMERATION_METHODS",
  "ESTIMATE_METHOD",
  "ADULT_PRESENCE",
  "JACK_PRESENCE",
  "NO_INSPECTIONS_USED",
  "START_DTT",
  "RUN_TYPE",
  "INDEX_YN",
  "ACCURACY",
  "PRECISION",
  "RELIABILITY",
  "ESTIMATE_STAGE"
)

field_roles <- data.frame(
  `Field Name` = wanted_fields,
  `Role in updated guidance` = c(
    "Stores Type 1--6 estimate classification (includes some legacy non-Type labels)",
    "Primary field method (enumeration) used to scope method-family checks",
    "Primary analysis method (estimation) and special cases (combined, calibrated, unknown)",
    "Supports presence/not-detected pathways (Type 6 context)",
    "Supports presence/not-detected pathways (Type 6 context)",
    "Supports effort/visit thresholds (VISITS and related downgrades)",
    "Supports timing/coverage interpretation (inspection start date)",
    "Supports timing context when multiple runs occur in a season",
    "Flags index (partial coverage) estimates (relative-abundance context)",
    "Legacy qualitative field; not a substitute for quantified uncertainty metadata",
    "Legacy qualitative field; not a substitute for quantified uncertainty metadata",
    "Legacy/import field (historical); not consistently present",
    "QA/workflow stage (preliminary/near final/final); not a type determinant"
  ),
  check.names = FALSE
)

if (file.exists(dd_path)) {
  dd <- read.csv(
    dd_path,
    stringsAsFactors = FALSE,
    check.names = FALSE,
    fileEncoding = "latin1"
  )

  dd_small <- dd[dd[["Field Name"]] %in% wanted_fields, c("Field Name", "Field Definition")]
  dd_small <- merge(dd_small, field_roles, by = "Field Name", all.x = TRUE)
  dd_small <- dd_small[match(wanted_fields, dd_small[["Field Name"]]), ]

  dd_small[["Field Definition"]] <- gsub("\\s+", " ", dd_small[["Field Definition"]])
  dd_small[["Field Definition"]] <- ifelse(
    nchar(dd_small[["Field Definition"]]) > 140,
    paste0(substr(dd_small[["Field Definition"]], 1, 139), "â€¦"),
    dd_small[["Field Definition"]]
  )
} else {
  dd_small <- data.frame(
    `Field Name` = wanted_fields,
    `Field Definition` = "(NuSEDS data dictionary CSV not present.)",
    check.names = FALSE
  )
  dd_small <- merge(dd_small, field_roles, by = "Field Name", all.x = TRUE)
  dd_small <- dd_small[match(wanted_fields, dd_small[["Field Name"]]), ]
}

csas_kable(
  dd_small,
  escape = TRUE,
  bold_header = FALSE,
  font_size = 8,
  col_names = c("Field", "Definition (truncated)", "Role in updated guidance"),
  align = c("l", "l", "l"),
  caption = "NuSEDS fields relevant to estimate-type classification and how they relate to the updated guidance (see the NuSEDS data dictionary in docs/context/)."
) |>
  csas_colspec(1, width = "2.5cm") |>
  csas_colspec(2, width = "5.5cm") |>
  csas_colspec(3, width = "6.5cm")
```

## Method families

```{r method-family-table}
method_families <- data.frame(
  Code = c("FS", "V", "A", "S", "T", "R", "P", "M"),
  `Method family` = c(
    "Fixed site census (manual or electronic)",
    "Visual ground or snorkel count",
    "Aerial survey count",
    "Hydroacoustic sonar count (modelled)",
    "Trap model (non-spanning)",
    "Redd survey",
    "Electrofishing CPUE index",
    "Mark-recapture program"
  ),
  `Best attainable type` = c("1", "2", "3", "2", "2", "2", "3", "2"),
  check.names = FALSE
)

csas_kable(
  method_families,
  escape = TRUE,
  bold_header = FALSE,
  font_size = 9,
  align = c("c", "l", "c"),
  caption = "Method families encoded in the property-first guidance and the best attainable Type before conservative downgrades."
) |>
  csas_colspec(1, width = "1.2cm") |>
  csas_colspec(2, width = "10.8cm") |>
  csas_colspec(3, width = "2.5cm")
```
